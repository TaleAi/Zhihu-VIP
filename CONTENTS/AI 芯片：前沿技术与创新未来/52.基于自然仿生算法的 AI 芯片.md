## 52.基于自然仿生算法的 AI 芯片
以上介绍的自然仿生算法在 DNN 的应用，大部分还是在 CPU 上进行模拟运算，很少使用专门的芯片。如果把自然仿生算法在专用芯片上实现，将可以达到高得多的效率和性能。事实上，近年来已经有很多在芯片上实现自然仿生算法的例子  [177,178]  。2019 年，方言等人已经基于铁电脉冲神经网络（F-SNN）实现了一种群体优化器  [179]  。本节介绍一些 PSO 和模拟退火芯片实现方面的探索。 


#### 粒子群优化的芯片实现


粒子群优化（PSO）算法的芯片实现难度较高。PSO 算法源于鱼类和鸟类群落的社会行为  [180]  。群体中的每个粒子（个体）都具有位置矢量，代表该问题的潜在解决方案。算法在整个搜索空间和每次迭代中将粒子初始化为随机位置，再算出速度矢量并用于更新每个粒子的位置。每个粒子的速度都受到粒子自身经验及邻居经验的影响。 


基于 FPGA 来实现 PSO 算法相对比较容易  [177]  。图 9.7 为一种 PSO 芯片的实现框图。假设群体由 N 个粒子组成，每次迭代使用成本函数 f 来测量群体中每个粒子 i 的拟合度（Fitness）。然后更新每个粒子 i 的位置，这受 3 个因素的影响：最后一次迭代的粒子速度、已知最佳位置的粒子和当前位置粒子之间的差异，以及已知最佳位置的群体与当前位置粒子之间的差异。后两项各自乘以  [0,1]  中的一个均匀随机数来随机改变每一项的影响，并乘以一个加速系数以扩展和平衡每一项的影响。每个粒子获得的最佳位置存储在矢量 p  i  中（图 9.7 中的 PBest），而群体中任何粒子获得的最佳位置存储在矢量 p  g  中（图中的 GBest）。然后更新每个粒子的速度矢量 v  i  。 


![img](https://pic1.zhimg.com/v2-74b11747b9882a6c94a3cb4a7e55e325.webp)

PSO 的算法实现通常使用浮点值。但是，相对于类似的定点操作，浮点运算通常需要数倍的逻辑资源。FPGA 通常包括许多嵌入式乘法器，可用于执行整数乘法，而无须使用任何 FPGA 可编程逻辑。为了硬件实现，PSO 算法被分解为在每个粒子上执行的 5 个操作：评估稳健性、更新粒子的最佳位置、更新全局最佳位置、更新速度和更新位置。这 5 个操作中的每一个都在单独的硬件模块中实现。 


由于可以并行执行 PBest 和 GBest 的更新，因而可以在 6 阶段流水线中组织这 5 个操作，包括初始提取和最终写入阶段。这款芯片使用了赛灵思的 FPGA，工作频率在 25～100 MHz 之间。 


#### 用忆阻器实现模拟退火算法


通过适当选择权重矩阵，可以使用 Hopfield 神经网络（Hopfield Neural Network，HNN）对任意优化问题进行编码和求解，最终将收敛到固定点。但是，如果仅采用 HNN 的架构来进行优化计算，它往往会陷入局部最小值，因为它没有实现系统能量状态提升来摆脱局部最小值的机制。 


如前所述，模拟退火算法是解决大型组合优化问题的有效技术。其中使用了随机或不相关的过程来扰动系统的状态，从而使其能够实现足以摆脱局部最小值的能量上升。当系统接近全局最小值时，噪声的大小会被调低，以使系统落到一个最佳值，即得到一个最优解决方案。 


为了实现可控的伪随机数生成以实现模拟退火，通常需要复杂的数字电路，这些电路一般具有较大的面积、较高的功耗和较长的时延。近年来，随着一些新型器件的不断开发和进步，有研究人员利用忆阻器的特性来实现 HNN  [181]  。忆阻器的交叉开关电路计算本身具有固有的模拟噪声，如果再加额外的忆阻器行列，可以注入可调电平的随机电报噪声（Random Telegraph Noise，RTN），在每一列中生成所需的独立噪声，如图 9.8 所示。这导致了一个类似于玻尔兹曼机的网络模型。氧化物忆阻器（如使用 TaO  x  的忆阻器）已表现出能够在某些偏置区域中产生可控的随机电报噪声，从而可以被用来摆脱局部最小值。 


![img](https://pic4.zhimg.com/v2-8308c42f5eb270dfbfcbddb22b90c087.webp)

这款用忆阻器实现的芯片，使用模拟退火算法，直接在模拟交叉开关阵列中解决了一个 60 个节点的最大割（Max-Cut）问题。 


备案号:YX01jbkWgwB9w7Lle

