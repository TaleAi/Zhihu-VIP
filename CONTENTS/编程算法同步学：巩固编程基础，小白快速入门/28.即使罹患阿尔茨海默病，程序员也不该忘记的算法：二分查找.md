## 28.即使罹患阿尔茨海默病，程序员也不该忘记的算法：二分查找
猜数游戏
----


我们先一起来玩一个小游戏：猜数字。


这个游戏需要两个人玩，一个攻方，一个守方——很像 1v1 的篮球赛，只不过互相攻防的不是篮球，而是数字！


  



![img](https://pic3.zhimg.com/v2-f4a5c1fbfb69c8c509ccc34025e7adca.webp)

### 游戏规则


具体游戏规则如下：


**【游戏双方】**：防守者，攻击者 


**【游戏准备】**：


* 防守者在 1 到 1000 之间任选一个自然数作为神秘数，暗自记住，然后开始游戏。

**【游戏过程】**：


* 

每一轮：


* 

攻击者猜一个数，问防守者：这个数是神秘数吗？


* 

防守者要根据事实，给出下面三个答案之一：


i）这个数就是神秘数；ii）这个数比神秘数小；iii）这个数比神秘数大


* 

游戏过程可以持续多轮


**【游戏结果】**：攻击者猜中神秘数，算攻击者赢，否则算防守者赢。


### 每次都猜中？


游戏很简单，不过有一个问题：有什么办法能让攻击者每次都赢吗？


  



![img](https://pic2.zhimg.com/v2-dd9bc1e769061a685718bff648afb85e.webp)

游戏的必胜攻略
-------


### 不限次数，攻击者必胜攻略


我们先把这个游戏更加简单化一点，假设题目的**要求**是：不限制猜测次数，只要能猜对就赢，那么攻击者有没有不败战法呢？


当然有啦！


总共就 1000 个数，如果我是攻击者，大不了从 1 开始猜，1 不对就 2，2 不对就 3，以此类推，一直猜到 1000，肯定能够猜到神秘数。


发现没有，这个游戏其实是个查找问题——我们要做的是从 1-1000 这 1000 个整数里找到对手预设的神秘数（目标数）。


如果仅仅是为了找到这个数字，我们尽可以采用顺序查找算法，一个个挨着找，一定能找到！


不限次数的猜数字游戏，可以用顺序查找算法解决，具体实现代码如下：


`tn = 165  # 这里可以是任意整数  

  

i = 1  

while i < 1001:  

    if (i == tn):  

        print("secrete number is ", i)  

        break  

  

    i = i + 1  

  

if i == 1001:  

    print("failed")`


***代码-1***


说明：


1） 井号（#）在 Python 中的作用是标识注释，一行代码里，所有出现在#后面的文字，都是程序的注释，仅仅为了给程序员读的，而不会被当作代码运行。


2） 如果把第一行改成 tn = 0 或者 tn = 1001 或者任何不在 1~1000 之间的数字，输出结果就会是：failed。


3） 本程序和之前的顺序查找有些不同，之前的顺序查找程序是将所有待查数字放到了一个 List 型的变量 arr 中，然后利用下标依次搜索，但这个程序却是没有任何 List 型变量，而仅仅是用整型变量 i 和目标数 tn 做依次比对。想想这是为什么？


for 循环和 while 循环
----------------


### 等价的两个循环


这里我们要介绍一个 Python 关键字：for。for 也是一个循环关键字，在大多数高级编程语言中，都有这个关键字。


它的作用很简单，我们来看一下下面完全等价的两端代码你就懂了：


代码 1：


`for n in range(1,1001):  

    print(n)`


代码 2：


`n=1  

while (n < 1001):  

    print(n)  

    n = n + 1`


代码 1 和代码 2 是完全一样的意思，都是分行依次打印出 1 到 1000 这 1000 个整数。


### Python 中的循环关键字：for


Python 中 for 的语法是这样的：


`for iterative_var in sequence:  

   statements(s)`


其中的 sequence 是一个序列，这个序列里有许多元素，这些元素可以是整数、实数、字符等类型，只要有序即可 。


而 iterative\_var 则是迭代（姑且认为是循环的另一种说法）变量，这个变量在每次循环中的值都不同，其取值实际是沿着 sequence 前后顺序，从头到尾依次取值。


我们先来看两个例子：


`for char in 'Python3':  

    print ('char :', char)`


输出结果为：



>   
> 


char : P char : y char : t char : h char : o char : n char : 3


`snacks = ['Cake', 'Cookie', 'Ice-cream', 'Pudding']  

for snack in snacks:  

    print ('Today snack :', snack)`


输出结果为：



>   
> 


Today snack : Cake Today snack : Cookie Today snack : Ice-cream Today snack : Pudding


### range() 函数


不过 for 最常用的还是用整型 itervative\_var 和 range() 相结合，比如下面例子：


`for i in range(1, 11):  

    print(i)`


输出结果：



>   
> 


1 2 3 4 5 6 7 8 9 10


发先规律没有？


上例中，i 是一个整型变量，在 for 循环中，它从 1 开始，到 11 之前那个数字结束，最终输出是 1-10，一共十个整数。


### 基于 for 循环的游戏解法


这个句型非常好用也非常常用，比如上面的代码-1 也可以改写成这样：


`tn = 165 # 这里可以是任意整数  

  

found = False  

  

for i in range(1,1001):  

    if i == tn:  

        print("secrete number is ", i)  

        found = True  

        break  

  

if not found:  

    print("failed")`


***代码-2***


代码-2 和代码-1 有一点不同，就是：在 for 循环中作为循环变量的 i，永远也不会大于循环上限——目前这个上线就是 1001 -1 = 1000。


就算 tn 是一个远大于 1000 的数字，for 循环也会在第 1000 次执行循环体后退出，此时 i 的值为 1000，而不是 1001。所以，我们需要一个额外的布尔型变量 found 来标识目标数是否被找到。


### for 循环 vs while 循环


for 和 while 之间的关系是：


* 

所有能用 for 表达的循环，都可以用 while 表达。


* 

反之，所有能够用 while 表达的循环，不一定都能用 for 表达——虽然如果在循环体内部加上比较复杂的判断，也可以让 for 和 while 做到等价的，不过这样未免就破坏了 for 的原生语义。



>   
> 


**NOTE**：对于零基础初学者，建议在第一轮学习的时候不要管 for，所有都用 while，这样比较不容易困惑。


限定猜测次数的猜数游戏
-----------


如果不限次数第猜测，攻击者当然可以赢，但是不断地猜个几百上千次，就算赢了，又有什么意思呢？


我们来吧游戏规则稍稍做一下修改，其他都是一样的，只有游戏结果改成：


**【游戏结果】**：攻击者在十次（含）之内猜中，算攻击者赢，否则是防守者赢。


这样一来，还能保证攻击者赢吗？


如果要保证攻击者赢，我们就需要一个算法，这个算法在 1-1000 这一千个数字中查找一个数，保证最多找十次，就能查找到。


这样的算法存在吗？


存在！这种算法叫做**二分查找**。


从「挨着找」到「跳着找」
------------


### 必须要「跳」


一共一千个数，我们只有十次机会去找到的目标数（也就是游戏里的神秘数），再像顺序查找那样一个个挨着找是不行了，肯定要跳着找！


  



![img](https://pic2.zhimg.com/v2-cd772cb3da1a6bcae2dfbd50b995e423.webp)

可是，怎么能保证跳的时候，不把目标数给跨过去呢？或者，至少万一跨过去了，我们也能够知道要回头？


### 确定「跳」的方向


首先，回头再看看我们的游戏规则：每次攻击者说出数字的时候，防守者不是简单说这个数是否目标数，当确定不是目标数时，还要明确回答攻击者刚说的这个数到底是：比目标数小；还是比目标数大。


其次，我们要猜测是 1~1000 这一千个数字，如果组成一个序列的话，是一个有序的序列——[1, 2, 3, 4, 5, ..., 998, 999, 1000]，它是一个从小到大逐步递增的有序数列。


以这两点作为前提，假设攻击者猜了一个数是 358，防守者说：「比目标数大」，那么我们就可以肯定我们要找的在 1~357 之间；如果防守者说「比目标数小」，则可以肯定目标数在 359 ~ 1000 之间——有了这样的明确信息，肯定可以保证下次查找不会「走错方向」，对吧。


### 确定「跳」的距离


当然了，如果我们上来真的猜 358，那会造成一种情况——如果它比目标数大还好，我们下次查找的区间只有 357 个数字，如果它比目标数小，那下次要找的就是包含 642 个数的区域了。两边也太不平衡了！


不如干脆猜中间数吧，如此一来，不管中间数比目标数是大是小，下次要找的区间都只有本次的一半！就像下图中马里奥那样：


  



![img](https://pic3.zhimg.com/v2-5151a4672439fc74dde1dec5b6b3952a.webp)

这种思路就叫做二分查找！


备案号:YX01GZ4p4kmLPAmJG


###### 2019-10-24 07:35
